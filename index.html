<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Social Engineering Radar Interface</title>
  <style>
/* Base styles */
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #0a1520;
  color: #e0e0e0;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.control-panel {
  background-color: #152535;
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.radar-display {
  background-color: #152535;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
}

h1, h2, h3 {
  color: #00ccff;
  text-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
  margin: 0 0 10px 0;
}

.control-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.control-header h2, .control-header h3 {
  margin: 0 15px 0 0;
  white-space: nowrap;
}

.slider-container {
  margin-bottom: 8px;
  display: flex;
  align-items: center;
}

.slider-container input[type="range"] {
  flex: 1;
  background: #203040;
  height: 8px;
  border-radius: 5px;
  outline: none;
}

.slider-container span {
  width: 40px;
  text-align: right;
  margin-left: 10px;
}

label {
  display: block;
  margin-bottom: 3px;
  color: #00ccff;
}

.context-selector {
  margin-bottom: 10px;
  flex: 1;
}

select {
  width: 100%;
  padding: 6px;
  background-color: #203045;
  color: #e0e0e0;
  border: 1px solid #00ccff;
  border-radius: 5px;
}

.svg-container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

svg {
  max-width: 100%;
  max-height: 100%;
}

.category-value {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
  align-items: center;
}

.category-value label {
  flex: 1;
  color: #00ccff;
  margin-bottom: 0;
}

.category-value input {
  flex: 2;
  height: 8px;
}

.category-value span {
  width: 40px;
  text-align: right;
  color: #00ccff;
}

#categoryControls {
  display: grid;
  grid-template-columns: 1fr;
  gap: 4px;
}



/* Theme styles */
body.light-theme {
  background-color: #e6f0f8;
  color: #333344;
}

.light-theme .control-panel, 
.light-theme .radar-display {
  background-color: #d0e4f5;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.light-theme h1, 
.light-theme h2, 
.light-theme h3,
.light-theme label {
  color: #0066aa;
  text-shadow: 0 0 5px rgba(0, 120, 200, 0.3);
}

.light-theme select,
.light-theme input[type="range"] {
  background-color: #b8d8f0;
  border: 1px solid #0088cc;
  color: #333344;
}

/* Rotated headers */
.rotated-header {
  display: flex;
  align-items: center;
}

.rotated-header h2, 
.rotated-header h3 {
  transform: rotate(0deg);
  transform-origin: center;
  white-space: nowrap;
  margin: 0;
  padding: 10px;
}

.control-header, 
.category-header {
  display: flex;
  align-items: flex-start;
  margin-bottom: 10px;
}

.option-toggles {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
}

.toggle-option {
  display: flex;
  align-items: center;
}

.toggle-option label {
  margin-right: 8px;
  white-space: nowrap;
}

.toggle-option select {
  width: auto;
  min-width: 100px;
}

/* Base styles rimangono invariati */

/* Media query per l'orientamento orizzontale (landscape) */
@media (orientation: landscape), (aspect-ratio: 4/3), (min-aspect-ratio: 1/1) {
  .container {
    flex-direction: row;
    height: 95vh;
  }
  
  .radar-display {
    order: 1;
    flex: 3;
    height: auto;
  }
  
  .control-panel {
    order: 2;
    flex: 1;
    max-width: 350px;
    height: auto;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    padding: 12px;
  }
  
  #categoryControls {
    flex: 1;
    overflow-y: visible;
  }
}

/* Media query per l'orientamento verticale (portrait) */
@media (orientation: portrait), (max-aspect-ratio: 1/1) {
  .container {
    flex-direction: column;
  }
  
  .radar-display {
    order: -1;
    height: 50vh;
  }
  
  .control-panel {
    width: auto;
    max-height: 50vh;
    overflow-y: auto;
  }
  
  .slider-container, .category-value {
    margin-bottom: 6px;
  }
  
  .context-selector {
    margin-bottom: 8px;
  }
}

/* Per schermi molto piccoli, manteniamo la media query per width ma aggiungiamo considerazioni sull'aspect ratio */
@media (max-width: 480px), (max-height: 480px) {
  body {
    padding: 10px;
  }
  
  .radar-display, .control-panel {
    padding: 10px;
  }
  
  /* Riduzione ulteriore per schermi molto piccoli con aspect ratio estremo */
  @media (max-aspect-ratio: 9/16) {
    .slider-container label, .category-value label {
      font-size: 0.9em;
    }
    
    h2, h3 {
      font-size: 1.1em;
    }
  }
}

/* Base layout styles without media queries */
.container.right-layout {
  flex-direction: row;
}

.container.left-layout {
  flex-direction: row-reverse;
}

.container.right-layout .radar-display,
.container.left-layout .radar-display {
  flex: 3;
}

.container.right-layout .control-panel,
.container.left-layout .control-panel {
  flex: 1;
  max-width: 350px;
}

/* Media query adjustments - keep these but make sure they don't override our explicit layout classes */
@media (orientation: portrait), (max-aspect-ratio: 1/1) {
  .container:not(.left-layout):not(.right-layout) {
    flex-direction: column;
  }
  
  .container.left-layout,
  .container.right-layout {
    /* Allow explicit layouts to work in portrait mode too */
    flex-direction: column;
  }
  
  .radar-display {
    order: -1;
    height: 50vh;
  }
  
  .control-panel {
    width: auto;
    max-height: 50vh;
    overflow-y: auto;
  }
}

/* Override for larger screens to ensure layout works */
@media (orientation: landscape), (min-aspect-ratio: 4/3) {
  .container.left-layout {
    flex-direction: row-reverse;
  }
  
  .container.right-layout {
    flex-direction: row;
  }
}

/* Aggiunta per dispositivi a schermo grande con aspect ratio ampio */
@media (min-aspect-ratio: 16/9) {
  .container {
    max-width: 95vw;
  }
  
  .radar-display {
    flex: 4; /* Dare più spazio al radar su display ultra-wide */
  }
}

/* Add this to your existing CSS within the style tag */

/* Ensure the radar maintains aspect ratio on vertical screens */
@media (orientation: portrait), (max-aspect-ratio: 1/1) {
  .radar-display {
    /* Change from fixed height to max-height */
    height: auto;
    max-height: 50vh;
    /* Add max-width to match max-height to ensure square-ish display */
    max-width: 100vw;
    aspect-ratio: 1/1;
    margin: 0 auto;
  }
  
  .svg-container {
    width: 100%;
    height: 100%;
    aspect-ratio: 1/1;
  }
  
  svg {
    width: 100%;
    height: 100%;
    max-height: 100vw; /* Ensure height doesn't exceed width */
  }
}

/* For extra small screens, reduce padding */
@media (max-width: 350px) {
  .radar-display {
    padding: 8px;
  }
}

  </style>
</head>
<body>
  <div class="container">
    <div class="control-panel">
      <div class="control-header">
        <div class="rotated-header">
          <h2>Control Panel</h2>
        </div>
        <div class="context-selector">
          <label for="context">Context:</label>
          <select id="context">
            <option value="full">Full Threat Level (All 100%)</option>
            <option value="general">General Corporate Environment</option>
            <option value="finance">Financial Services</option>
            <option value="healthcare">Healthcare</option>
            <option value="government">Government</option>
            <option value="education">Education</option>
            <option value="retail">Retail</option>
            <option value="manufacturing">Manufacturing</option>
            <option value="technology">Technology Companies</option>
            <option value="critical">Critical Infrastructure</option>
            <option value="remote">Remote Work Environment</option>
          </select>
        </div>
      </div>

      <div class="option-toggles">
        <div class="toggle-option">
          <label for="themeToggle">Theme:</label>
          <select id="themeToggle">
            <option value="dark">Dark Mode</option>
            <option value="light">Light Mode</option>
          </select>
        </div>
        
        <div class="toggle-option">
          <label for="layoutToggle">Layout:</label>
          <select id="layoutToggle">
            <option value="right">Radar on Right</option>
            <option value="left">Radar on Left</option>
          </select>
        </div>
      </div>
      
      <div class="slider-container">
        <label for="scanSpeed">Speed:</label>
        <input type="range" id="scanSpeed" min="0" max="40" value="7" step="0.1">
        <span id="speedValue">10s</span>
      </div>
      
      <div class="slider-container">
        <label for="beamWidth">Angle:</label>
        <input type="range" id="beamWidth" min="1" max="360" value="45">
        <span id="widthValue">45°</span>
      </div>
      
      <div class="slider-container">
        <label for="contrastLevel">Contrast:</label>
        <input type="range" id="contrastLevel" min="0" max="100" value="100">
        <span id="contrastValue">100%</span>
      </div>
      
      <div class="category-header">
        <div class="rotated-header">
          <h3>Threat Categories: select radar for info</h3>
        </div>
      </div>
      <div id="categoryControls">
        <!-- Category sliders will be added here dynamically -->
      </div>
    </div>
    
    <div class="radar-display">
      <div class="svg-container" id="svgContainer">
        <!-- SVG is directly embedded here -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 800" id="radar">
          <!-- Background and grid -->
          <defs>
            <radialGradient id="radarGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
              <stop offset="0%" stop-color="#103040" />
              <stop offset="100%" stop-color="#000810" />
            </radialGradient>
            <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur stdDeviation="5" result="blur" />
              <feComposite in="SourceGraphic" in2="blur" operator="over" />
            </filter>
            <filter id="outsideBeamGlow" x="-30%" y="-30%" width="160%" height="160%">
              <feGaussianBlur stdDeviation="3" result="blur" />
              <feComposite in="SourceGraphic" in2="blur" operator="over" />
            </filter>
          </defs>

          <!-- Background -->
          <circle cx="400" cy="400" r="390" fill="url(#radarGradient)" />
          
          <!-- Grid lines - enhanced with stroke-width and opacity -->
          <g stroke="#235" stroke-width=1" id="gridLines">
            <circle cx="400" cy="400" r="80" fill="none" stroke="#1a7" filter="url(#glow)" />
            <circle cx="400" cy="400" r="160" fill="none" stroke="#1a7" filter="url(#glow)" />
            <circle cx="400" cy="400" r="240" fill="none" stroke="#1a7" filter="url(#glow)" />
            <circle cx="400" cy="400" r="320" fill="none" stroke="#1a7" filter="url(#glow)" />
          </g>

          <!-- Grid lines - enhanced with stroke-width, opacity and dashed strokes -->
          <g stroke="#235" stroke-width="3" id="gridLines">
            <circle cx="400" cy="400" r="80" fill="none" stroke="#1a7" filter="url(#glow)" stroke-dasharray="5,5" />
            <circle cx="400" cy="400" r="160" fill="none" stroke="#1a7" filter="url(#glow)" stroke-dasharray="5,5" />
            <circle cx="400" cy="400" r="240" fill="none" stroke="#1a7" filter="url(#glow)" stroke-dasharray="5,5" />
            <circle cx="400" cy="400" r="320" fill="none" stroke="#1a7" filter="url(#glow)" stroke-dasharray="5,5" />
          </g>

          <!-- Grid radial lines - Corrected to be evenly spaced at 30° intervals with length of 410 units -->
          <g stroke="#235" stroke-width="3" id="gridRadials">
            <!-- 12 radial lines (30 degrees apart) - all with length of 410 units from center -->
            <line x1="400" y1="400" x2="400" y2="-10" /> <!-- 0° -->
            <line x1="400" y1="400" x2="605" y2="45" /> <!-- 30° -->
            <line x1="400" y1="400" x2="755" y2="195" /> <!-- 60° -->
            <line x1="400" y1="400" x2="810" y2="400" /> <!-- 90° -->
            <line x1="400" y1="400" x2="755" y2="605" /> <!-- 120° -->
            <line x1="400" y1="400" x2="605" y2="755" /> <!-- 150° -->
            <line x1="400" y1="400" x2="400" y2="810" /> <!-- 180° -->
            <line x1="400" y1="400" x2="195" y2="755" /> <!-- 210° -->
            <line x1="400" y1="400" x2="45" y2="605" /> <!-- 240° -->
            <line x1="400" y1="400" x2="-10" y2="400" /> <!-- 270° -->
            <line x1="400" y1="400" x2="45" y2="195" /> <!-- 300° -->
            <line x1="400" y1="400" x2="195" y2="45" /> <!-- 330° -->
          </g>
          
          <!-- Polygon container -->
          <g id="polygon">
            <!-- Polygon will be added dynamically -->
          </g>
          
          <!-- Category group -->
          <g id="categories">
            <!-- Categories will be added dynamically by JavaScript -->
          </g>
          
          <!-- Scanner -->
          <g id="scanner">
            <path id="scannerBeam" d="M 400,400 L 400,0 A 400,400 0 0,1 800,400 Z" fill="rgba(0,255,200,0.2)" stroke="rgba(0,255,200,0.8)" stroke-width="2" transform="rotate(0 400 400)">
              <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 400 400" to="360 400 400" dur="10s" repeatCount="indefinite" />
            </path>
            <circle cx="400" cy="400" r="15" fill="#0ff" filter="url(#glow)" />
          </g>
          
          <!-- Additional decorative elements -->
          <circle cx="400" cy="400" r="8" fill="#0ff" />
          <text x="400" y="375" text-anchor="middle" fill="#0ff" font-family="'Courier New', monospace" font-size="16" filter="url(#glow)">SOCIAL ENGINEERING</text>
          <text x="400" y="435" text-anchor="middle" fill="#0ff" font-family="'Courier New', monospace" font-size="16" filter="url(#glow)">THREAT SCANNER</text>
        </svg>
      </div>
    </div>
  </div>

  <script>
  
// Define tooltip content for each category
const categoryInfo = {
  phishing: "PHISHING: Attackers impersonate trusted entities via email or fake websites to steal credentials or install malware. Common tactics include urgent requests, suspicious links, and spoofed sender addresses. ----- Defense: Independent verification of senders, distrust of urgent requests, checking URLs before clicking.",
  pretexting: "PRETEXTING: Creating a fabricated scenario to obtain information or access. Involves research to build a credible story that manipulates victims into breaking security protocols. ----- Defense: Identity verification through official channels, staff training on verification protocols.",
  baiting: "BAITING: Exploits curiosity or greed by offering something enticing (USB drives, free downloads) that contains malware or leads to credential theft. ----- Defense: Never use devices of unknown origin, scan all external devices for viruses.",
  quidproquo: "QUID PRO QUO: Attackers promise a benefit in exchange for information or action, often impersonating IT support offering assistance while installing malware. ----- Defense: Verify the identity of those offering unsolicited assistance, use only official support channels.",
  tailgating: "TAILGATING: Physical security breach where unauthorized individuals follow authorized personnel into restricted areas by exploiting courtesy. ----- Defense: Badge control, awareness raising on not letting strangers in, visitor registration procedures.",
  vishing: "VISHING: Voice phishing using phone calls to deceive victims into revealing sensitive information or making security mistakes. ----- Defense: Never provide sensitive information over the phone, call official numbers to verify.",
  smishing: "SMISHING: SMS phishing using text messages containing malicious links that lead to credential theft or malware installation. ----- Defense: Do not click links in suspicious SMS, verify independently via official channels.",
  watering: "WATERING: Compromising websites frequently visited by targets, infecting visitors with malware when they access the site. ----- Defense: Update browsers and systems, use firewalls and security software.",
  impersonation: "IMPERSONATION: Attackers assume the identity of trusted individuals or organizations, often combining online and offline tactics. ----- Impersonation remediation includes: * Verifying identity through secondary channels; * Using multi-factor authentication; * Checking sender email addresses and domains; * Beware of unusual or urgent requests; * Direct contact with the organization through official channels; * Training staff on how to recognize impersonation attempts; * Implementing anti-spoofing filters (DMARC, SPF, DKIM).",
  dumpster: "DUMPSTER: Searching through discarded materials to find sensitive information that wasn't properly destroyed or disposed. ----- Dumpster diving remedies:; * Shredding sensitive documents before disposal; * Use secure, locked waste containers; * Implement secure erasure policies for storage devices; * Remove labels with sensitive information; * Edit storage to reduce paper; * Physical access controls to waste disposal areas; * Educate employees on proper disposal procedures.",
  scareware: "SCAREWARE: False alarms and fictitious threats designed to frighten users into purchasing unwanted software or revealing information. ----- Defense: Use only legitimate antivirus software, ignore alarmist pop-ups, verify through official channels.",
  osint: "OSINT: Using publicly available information sources to build detailed profiles for targeting specific individuals or organizations. ----- Remedies for OSINT (Open Source Intelligence): * Limit personal/business information shared online; * Configure privacy settings on social media; * Regularly monitor your digital presence; * Remove sensitive data from public sites (data brokers); * Use pseudonyms for non-professional accounts; * Avoid sharing metadata in public files; * Implement company policies on information disclosure; * Monitor mentions of the organization with alert tools."
};

// Create tooltip element and add to DOM
const tooltip = document.createElement('div');
tooltip.id = 'category-tooltip';
tooltip.style.cssText = `
  position: absolute;
  background: rgba(10, 30, 50, 0.7);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #00ccff;
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
  font-size: 14px;
  max-width: 250px;
  z-index: 1000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  text-align: left;
  backdrop-filter: blur(3px);
`;
document.body.appendChild(tooltip);

// Add this function to show tooltip
function showTooltip(e, categoryId) {
  const info = categoryInfo[categoryId];
  if (!info) return;
  
  // Position the tooltip near the cursor
  const x = e.clientX;
  const y = e.clientY;
  
  tooltip.textContent = info;
  tooltip.style.left = `${x + 15}px`;
  tooltip.style.top = `${y + 15}px`;
  tooltip.style.opacity = '1';
  
  // Apply theme-specific styling
  if (document.body.classList.contains('light-theme')) {
    tooltip.style.background = 'rgba(200, 230, 255, 0.7)';
    tooltip.style.color = '#003366';
    tooltip.style.borderColor = '#0088cc';
  } else {
    tooltip.style.background = 'rgba(10, 30, 50, 0.7)';
    tooltip.style.color = '#fff';
    tooltip.style.borderColor = '#00ccff';
  }
}

// Add this function to hide tooltip
function hideTooltip() {
  tooltip.style.opacity = '0';
}
  
    // Social Engineering Categories - updated to 12 entries to match the 12 radial lines
    const categories = [
      { id: 'phishing', name: 'Phishing' },
      { id: 'pretexting', name: 'Pretexting' },
      { id: 'baiting', name: 'Baiting' },
      { id: 'quidproquo', name: 'Quid Pro Quo' },
      { id: 'tailgating', name: 'Tailgating' },
      { id: 'vishing', name: 'Vishing' },
      { id: 'smishing', name: 'Smishing' },
      { id: 'watering', name: 'Watering Hole' },
      { id: 'impersonation', name: 'Impersonation' },
      { id: 'dumpster', name: 'Dumpster Diving' },
      { id: 'scareware', name: 'Scareware' },
      { id: 'osint', name: 'OSINT Exploitation' }
    ];
    
    // Predefined contexts with threat values for each category
    const contexts = {
      full: {
        phishing: 100, pretexting: 100, baiting: 100, quidproquo: 100, 
        tailgating: 100, vishing: 100, smishing: 100, watering: 100, 
        impersonation: 100, dumpster: 100, scareware: 100, osint: 100
      },
      general: {
        phishing: 70, pretexting: 65, baiting: 55, quidproquo: 45, 
        tailgating: 50, vishing: 60, smishing: 65, watering: 55, 
        impersonation: 75, dumpster: 35, scareware: 60, osint: 70
      },
      finance: {
        phishing: 90, pretexting: 85, baiting: 60, quidproquo: 70, 
        tailgating: 65, vishing: 80, smishing: 75, watering: 70, 
        impersonation: 85, dumpster: 40, scareware: 75, osint: 80
      },
      healthcare: {
        phishing: 80, pretexting: 75, baiting: 50, quidproquo: 65, 
        tailgating: 70, vishing: 60, smishing: 55, watering: 60, 
        impersonation: 80, dumpster: 60, scareware: 65, osint: 75
      },
      government: {
        phishing: 85, pretexting: 80, baiting: 55, quidproquo: 60, 
        tailgating: 75, vishing: 70, smishing: 65, watering: 80, 
        impersonation: 90, dumpster: 50, scareware: 60, osint: 85
      },
      education: {
        phishing: 75, pretexting: 60, baiting: 70, quidproquo: 50, 
        tailgating: 80, vishing: 40, smishing: 75, watering: 65, 
        impersonation: 70, dumpster: 45, scareware: 55, osint: 60
      },
      retail: {
        phishing: 65, pretexting: 70, baiting: 80, quidproquo: 55, 
        tailgating: 45, vishing: 50, smishing: 70, watering: 50, 
        impersonation: 65, dumpster: 55, scareware: 75, osint: 60
      },
      manufacturing: {
        phishing: 60, pretexting: 65, baiting: 55, quidproquo: 45, 
        tailgating: 70, vishing: 50, smishing: 40, watering: 45, 
        impersonation: 65, dumpster: 60, scareware: 50, osint: 70
      },
      technology: {
        phishing: 80, pretexting: 70, baiting: 65, quidproquo: 50, 
        tailgating: 55, vishing: 60, smishing: 70, watering: 85, 
        impersonation: 75, dumpster: 40, scareware: 65, osint: 85
      },
      critical: {
        phishing: 90, pretexting: 85, baiting: 70, quidproquo: 75, 
        tailgating: 85, vishing: 80, smishing: 70, watering: 85, 
        impersonation: 90, dumpster: 70, scareware: 75, osint: 90
      },
      remote: {
        phishing: 85, pretexting: 75, baiting: 60, quidproquo: 65, 
        tailgating: 20, vishing: 75, smishing: 85, watering: 75, 
        impersonation: 80, dumpster: 15, scareware: 80, osint: 75
      }
    };

    // Variable to track beam position for focus effects
    let currentBeamAngle = 0;

    // Get references to elements
    const svgContainer = document.getElementById('svgContainer');
    const contextSelect = document.getElementById('context');
    const scanSpeedSlider = document.getElementById('scanSpeed');
    const beamWidthSlider = document.getElementById('beamWidth');
    const contrastSlider = document.getElementById('contrastLevel');
    const speedValue = document.getElementById('speedValue');
    const widthValue = document.getElementById('widthValue');
    const contrastValue = document.getElementById('contrastValue');
    const categoryControls = document.getElementById('categoryControls');
    
    // Get reference to the SVG
    const svgElement = document.getElementById('radar');
    const categoriesGroup = svgElement.querySelector('#categories');
    const polygonGroup = svgElement.querySelector('#polygon');
    const scannerBeam = svgElement.querySelector('#scannerBeam');
    const scannerAnimation = svgElement.querySelector('#scannerBeam animateTransform');
    const gridLines = svgElement.querySelector('#gridLines');
    const gridRadials = svgElement.querySelector('#gridRadials');
    
    // Circle radius for data points
    const CIRCLE_RADIUS = 10;
    
    // Create category controls and initial visualization
    function initializeInterface() {
      // Create category elements on the radar
      categories.forEach((category, index) => {
        const angle = (index * 30) * (Math.PI / 180);
        
        // Create control for each category
        const controlDiv = document.createElement('div');
        controlDiv.className = 'category-value';
        
        const label = document.createElement('label');
        label.htmlFor = category.id;
        label.textContent = category.name;
        
        const input = document.createElement('input');
        input.type = 'range';
        input.id = category.id;
        input.min = '0';
        input.max = '100';
        input.value = '50';
        
        const valueSpan = document.createElement('span');
        valueSpan.id = `${category.id}Value`;
        valueSpan.textContent = '50%';
        
        controlDiv.appendChild(label);
        controlDiv.appendChild(input);
        controlDiv.appendChild(valueSpan);
        categoryControls.appendChild(controlDiv);
        
        // Event listener for slider change
        input.addEventListener('input', updateRadar);
      });
      
      // Apply initial context
      applyContext('full');
      
      // Add event listeners
      contextSelect.addEventListener('change', () => {
        applyContext(contextSelect.value);
      });
      

      // After the existing event listener for scanSpeedSlider
      scanSpeedSlider.addEventListener('input', function() {
        updateScannerSpeed();
        // Force refresh of focus effects when speed changes
        currentBeamAngle = 0; // Reset beam angle
      });

      beamWidthSlider.addEventListener('input', updateBeamWidth);
      contrastSlider.addEventListener('input', updateBackgroundContrast);
      
      // Theme toggle handler
      const themeToggle = document.getElementById('themeToggle');
      themeToggle.addEventListener('change', function() {
        if (this.value === 'light') {
          document.body.classList.add('light-theme');
        } else {
          document.body.classList.remove('light-theme');
        }
      });



// Layout toggle handler
const layoutToggle = document.getElementById('layoutToggle');
const container = document.querySelector('.container');
layoutToggle.addEventListener('change', function() {
  // Remove any existing layout classes first
  container.classList.remove('left-layout', 'right-layout');
  
  // Add the appropriate class based on selection
  if (this.value === 'left') {
    container.classList.add('left-layout');
  } else {
    container.classList.add('right-layout'); // Using an explicit class for right layout
  }
});

      // Update these SVG elements for light/dark mode
      themeToggle.addEventListener('change', function() {
        const isLightMode = this.value === 'light';
        const bgGradient = svgElement.querySelector('#radarGradient');
        
        // Update radar background for light/dark theme
        if (isLightMode) {
          bgGradient.querySelector('stop:first-child').setAttribute('stop-color', '#d0e4f5');
          bgGradient.querySelector('stop:last-child').setAttribute('stop-color', '#a8c8e0');
          gridLines.querySelectorAll('circle').forEach(circle => {
            circle.setAttribute('stroke', '#0088aa');
          });
          gridRadials.querySelectorAll('line').forEach(line => {
            line.setAttribute('stroke', '#0088aa');
          });
        } else {
          bgGradient.querySelector('stop:first-child').setAttribute('stop-color', '#103040');
          bgGradient.querySelector('stop:last-child').setAttribute('stop-color', '#000810');
          gridLines.querySelectorAll('circle').forEach(circle => {
            circle.setAttribute('stroke', '#1a7');
          });
          gridRadials.querySelectorAll('line').forEach(line => {
            line.setAttribute('stroke', '#235');
          });
        }
        
        // Force radar update to reflect new theme
        updateRadar();
        updateBackgroundContrast();
      });
      
      // Initial render
      updateRadar();
      updateScannerSpeed();
      updateBeamWidth();
      updateBackgroundContrast();
      
      // Setup the focus animation loop
      startFocusAnimation();
    }
    
    // Apply selected context values to sliders
    function applyContext(contextName) {
      const contextData = contexts[contextName];
      categories.forEach(category => {
        const slider = document.getElementById(category.id);
        const valueSpan = document.getElementById(`${category.id}Value`);
        slider.value = contextData[category.id];
        valueSpan.textContent = `${contextData[category.id]}%`;
      });
      updateRadar();
    }
    
    // Update radar visualization based on slider values
    function updateRadar() {

    
      // Clear previous elements
      categoriesGroup.innerHTML = '';
      polygonGroup.innerHTML = '';
      
      // Collect points for the polygon
      const points = [];
      const categoryPoints = [];
      
      // Draw each category
      categories.forEach((category, index) => {
        const value = parseInt(document.getElementById(category.id).value);
        const valueSpan = document.getElementById(`${category.id}Value`);
        valueSpan.textContent = `${value}%`;
        
        // Calculate position
        const angle = (index * 30) * (Math.PI / 180);
        const distanceFactor = value / 100;
        const distance = 320 * distanceFactor; // Max radius is 320
        
        const x = 400 + Math.sin(angle) * distance;
        const y = 400 - Math.cos(angle) * distance;
        
        // Add point to polygon points array
        points.push({ x, y });
        categoryPoints.push({ x, y, angle, value, category });
        
        // Create circle for category with glow effect
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", CIRCLE_RADIUS);
        circle.setAttribute("fill", getColorForValue(value));
        circle.setAttribute("filter", "url(#glow)");
        circle.setAttribute("class", "category-point");
        circle.setAttribute("data-angle", angle);
	circle.setAttribute("data-category", category.id);
        
// Modify the category element creation in updateRadar() function
// Add this inside the updateRadar() function, after creating circle elements
function attachTooltipEvents(element, category) {
  element.addEventListener('mouseenter', (e) => showTooltip(e, category.id));
  element.addEventListener('mousemove', (e) => {
    // Update position on mousemove to follow cursor
    tooltip.style.left = `${e.clientX + 15}px`;
    tooltip.style.top = `${e.clientY + 15}px`;
  });
  element.addEventListener('mouseleave', hideTooltip);
  
  // Add touch support for mobile
  element.addEventListener('touchstart', (e) => {
    // Prevent default to avoid scrolling
    e.preventDefault();
    const touch = e.touches[0];
    showTooltip(touch, category.id);
  });
  element.addEventListener('touchend', hideTooltip);
  element.addEventListener('touchcancel', hideTooltip);
}
	
        // Calculate label position - distance of circle diameter (2*CIRCLE_RADIUS) from the point
        let labelDistance = distance + (CIRCLE_RADIUS * 2);
        
        // If label is below center (y > 400), increase the distance by 50%
        if (y > 401) {
          labelDistance = distance + (CIRCLE_RADIUS * 2) * 1.5; // 50% further
        }
        
        const labelX = 400 + Math.sin(angle) * labelDistance;
        const labelY = 400 - Math.cos(angle) * labelDistance;
        
        // Create text label with rotation to follow the radial line
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", labelX);
        text.setAttribute("y", labelY);
        text.setAttribute("fill", "#80d0ff");
        text.setAttribute("font-family", "'Courier New', monospace");
        text.setAttribute("font-size", "14");
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("class", "category-label");
        text.setAttribute("data-angle", angle);
	text.setAttribute("data-category", category.id);
        
	// Add event listeners to label for tooltip
         attachTooltipEvents(text, category);
	
        // Rotate text to follow the radial line
        // Add 90 degrees if on the left side to flip the text right-side up
        let rotation = angle * (180 / Math.PI);
        if (rotation > 90 && rotation < 270) {
          rotation += 180;
        }
        text.setAttribute("transform", `rotate(${rotation} ${labelX} ${labelY})`);
        text.textContent = category.name;
        
        // Add to SVG
        categoriesGroup.appendChild(circle);
        categoriesGroup.appendChild(text);
      });
      
      // Create polygon connecting all points with glowing effect
      if (points.length > 2) {
        const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const pointsString = points.map(p => `${p.x},${p.y}`).join(' ');
        polygon.setAttribute("points", pointsString);
        polygon.setAttribute("fill", "rgba(128, 0, 255, 0.3)");
        polygon.setAttribute("stroke", "rgba(160, 32, 240, 0.8)");
        polygon.setAttribute("stroke-width", "2");
        polygon.setAttribute("filter", "url(#glow)");
        
        // Add polygon to SVG (before the category circles)
        polygonGroup.appendChild(polygon);
      }
      
      // Add connecting lines from center to each point
      categoryPoints.forEach(point => {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", "400");
        line.setAttribute("y1", "400");
        line.setAttribute("x2", point.x);
        line.setAttribute("y2", point.y);
        line.setAttribute("stroke", getColorForValue(point.value));
        line.setAttribute("stroke-width", "2");
        line.setAttribute("stroke-opacity", "0.6");
        line.setAttribute("class", "category-line");
        line.setAttribute("data-angle", point.angle);
        
        // Add line before the circles so circles appear on top
        categoriesGroup.insertBefore(line, categoriesGroup.firstChild);
      });
    }
    
    // Update scanner animation speed
    function updateScannerSpeed() {
      const speed = scanSpeedSlider.value;
      speedValue.textContent = `${speed}s`;
      scannerAnimation.setAttribute("dur", `${speed}s`);
    }
    
    // Update scanner beam width
    function updateBeamWidth() {
      const width = beamWidthSlider.value;
      widthValue.textContent = `${width}°`;
      
      // Calculate path for beam
      const startAngle = -width / 2;
      const endAngle = width / 2;
      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;
      
      const startX = 400 + 400 * Math.sin(startRad);
      const startY = 400 - 400 * Math.cos(startRad);
      const endX = 400 + 400 * Math.sin(endRad);
      const endY = 400 - 400 * Math.cos(endRad);
      
      const largeArcFlag = width > 180 ? 1 : 0;
      
      const path = `M 400,400 L ${startX},${startY} A 400,400 0 ${largeArcFlag},1 ${endX},${endY} Z`;
      scannerBeam.setAttribute("d", path);
    }
    
    // Update background contrast
    function updateBackgroundContrast() {
      const contrast = contrastSlider.value;
      contrastValue.textContent = `${contrast}%`;
      
      // Calculate opacity based on contrast
      const opacity = contrast / 100;
      
      // Apply opacity to grid lines and radials that aren't being scanned
      gridLines.querySelectorAll('circle').forEach(circle => {
        circle.setAttribute('stroke-opacity', opacity);
      });
      
      gridRadials.querySelectorAll('line').forEach(line => {
        line.setAttribute('stroke-opacity', opacity);
      });
      
      // Apply to polygon
      polygonGroup.childNodes.forEach(node => {
        if (node.nodeName === 'polygon') {
          const fillParts = node.getAttribute('fill').split(',');
          const strokeParts = node.getAttribute('stroke').split(',');
          
          if (fillParts.length === 4 && strokeParts.length === 4) {
            // Update the opacity part (last number before the closing parenthesis)
            fillParts[3] = `${0.3 * opacity})`;
            strokeParts[3] = `${0.8 * opacity})`;
            
            node.setAttribute('fill', fillParts.join(','));
            node.setAttribute('stroke', strokeParts.join(','));
          }
        }
      });
    }
    
    
    
 // Start the focus animation loop
function startFocusAnimation() {
  function updateFocus() {
    // Get current rotation from the animation
    // Get the current scanner speed from the slider
    const scanSpeed = parseFloat(scanSpeedSlider.value);
  
    // This extracts the current angle by watching the animation transform
    const animationDuration = scanSpeed; // Use the current scanner speed directly
    const elapsed = (Date.now() % (animationDuration * 1000)) / (animationDuration * 1000);
    const currentBeamAngle = elapsed * 360; // Convert to degrees (0-360)
    
    // Get beam width
    const beamWidth = parseInt(beamWidthSlider.value);
    const halfBeamWidth = beamWidth / 2;
    
    // Check all category elements and apply focus/unfocus effects
    const categoryElements = document.querySelectorAll('.category-point, .category-label, .category-line');
    categoryElements.forEach(el => {
      // Get element angle in degrees (elements store angles in radians)
      const elementAngleRad = parseFloat(el.getAttribute('data-angle'));
      const elementAngleDeg = (elementAngleRad * 180 / Math.PI) % 360;
      
      // Calculate angular difference with wraparound handling
      let angleDiff = Math.abs(elementAngleDeg - currentBeamAngle);
      if (angleDiff > 180) angleDiff = 360 - angleDiff;
      //console.log(' >> ' + angleDiff + ' <> ' + halfBeamWidth );
      // Check if element is within the beam span
      if (angleDiff <= halfBeamWidth) {
          // Calculate intensity based on proximity to beam center and scanner speed
          // Faster scanner speed reduces intensity, slower speed increases it
          const speedFactor = Math.max(0.5, Math.min(1.5, 10/scanSpeed));
          const intensity = (1 - (angleDiff / halfBeamWidth)) * speedFactor;
  
          // Apply smooth size transition based on intensity
          if (el.classList.contains('category-point')) {
            // Smoothly scale size based on intensity
            const scaleFactor = 1 + (intensity * 1); // Scale up to 2x
    
            el.setAttribute('r', CIRCLE_RADIUS * scaleFactor);
            el.setAttribute('filter', 'url(#glow)');
            // Increase opacity based on intensity
            el.setAttribute('fill-opacity', 0.7 + (intensity * 0.3));

        } else if (el.classList.contains('category-label')) {
          // Increase font size and apply glow based on intensity
          const fontSize = 14 + (intensity * 2);
          el.setAttribute('font-size', fontSize);
          el.setAttribute('filter', 'url(#glow)');
        } else if (el.classList.contains('category-line')) {
          // Increase line width based on intensity
          const strokeWidth = 1.5 + (intensity * 1.5);
          el.setAttribute('stroke-width', strokeWidth);
          el.setAttribute('stroke-opacity', 0.4 + (intensity * 0.5));
        }
      } else {
        // Element is outside the beam - return to default state
        if (el.classList.contains('category-point')) {
          el.setAttribute('r', CIRCLE_RADIUS);
          el.setAttribute('filter', 'url(#outsideBeamGlow)');
          el.setAttribute('fill-opacity', 0.7);
        } else if (el.classList.contains('category-label')) {
          el.setAttribute('font-size', '14');
          el.setAttribute('filter', 'none');
        } else if (el.classList.contains('category-line')) {
          el.setAttribute('stroke-width', '1.5');
          el.setAttribute('stroke-opacity', '0.4');
        }
      }
    });
    
    // Continue the animation loop
    requestAnimationFrame(updateFocus);
  }
  
  // Start the animation loop
  requestAnimationFrame(updateFocus);
}   
    
    


    
    // Helper functions
    function getColorForValue(value) {
      // Red for high values, yellow for medium, green for low
      if (value > 75) return "#ff5050";
      if (value > 50) return "#ffaa00";
      if (value > 25) return "#aaff00";
      return "#00ff80";
    }
    


    // Initialize the interface
    initializeInterface();
  </script>
</body>
</html>
